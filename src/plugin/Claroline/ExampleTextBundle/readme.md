# Getting started with Claroline plugin development

This tutorial aims to explain how to develop a plugin that manages a new resource type in the Claronext LMS.

## Prerequisites

### PHP

Claronext is developed in PHP and needs at least the 5.3 version.

### Symfony

Claronext is built on top of the Symfony framework (version 2). Plugins that you develop will be based on the same framework so you should have at least basic knowledge of it.

Please find the Symfony documentation here:
http://symfony.com/doc/current/index.html.

### Doctrine

Claronext makes a strong use of the Doctrine ORM. You have to use it too, at least for the parts that will be managed by the platform (mainly the resources).

We recommand anyway that you use the ORM for your whole plugin to be "database independant".

It is good practice to check SQL requests generated by the ORM and optimize the code to minimize the load on the database. The DQL (Doctrine Query language) is the right tool to "force" Doctrine  requesting the database the way **you** want.

Please find the Doctrine documentation here:
http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/index.html

## Directory structure

You must put the code of your plugin in the *src/plugin* folder.

You may choose to develop in the *Claroline* vendor folder or create your own one (e.g. *src/plugin/myVendorName*). There you create a new folder for each plugin.

As plugins are Symfony2 [bundles](http://symfony.com/doc/2.0/cookbook/bundles/best_practices.html), it is strongly recommanded that you follow bundles naming rules. So the folder of your plugin should be like this: *src/plugin/myVendorName/myPluginNameBundle*.

## Database tables

You must create a migration class building your tables in the existing database.

The class must extend [*BundleMigration*](http://symfony.com/doc/2.0/bundles/DoctrineMigrationsBundle/index.html) and be placed in the *Migrations* folder. Its name must start with *Version* and end with a timestamp (YYYMMDDHHMMSS); e.g. *Version20121002000000.php*.

This class will be executed by the plateform when installing your plugin. It must contains two methods: up() and down(). They will be called to create or remove your tables to/from the database.

    /**
    *  BundleMigration is written on top of Doctrine\DBAL\Migrations\AbstractMigration
    *  and contains some helper methods.
    *  You can use the doctrine migration class as well (see the doctrine doc).
    */
    class Version20121002000000 extends BundleMigration
    {

        /**
        * Will be fired at the plugin installation.
        * @param \Doctrine\DBAL\Schema\Schema $schema
        */
        public function up(Schema $schema)
        {
            $this->createExampleTextTable($schema);
        }

        /**
        * Will be fired at the plugin uninstallation.
         * @param \Doctrine\DBAL\Schema\Schema $schema
         */
        public function down(Schema $schema)
        {
            $schema->dropTable('claro_example_text');
        }

        /**
        * Create the 'claro_example_text' table.
        * @param \Doctrine\DBAL\Schema\Schema $schema
        */
        public function createExampleTextTable(Schema $schema)
        {
            // Table creation
            $table = $schema->createTable('claro_example_text');
            // Add an auto increment id
            $this->addId($table);
            // Add a column
            $table->addColumn('text', 'text');
        }
    }

## Doctrine entities

Define your Doctrine entities in the Entity folder.

If your entity is a resource that must be recognized by the platform and manageable in the resource manager then you must extend the *Claroline\CoreBundle\Entity\Resource\AbstractResource* class.

    /**
    * @ORM\Entity
    * @ORM\Table(name="claro_example_text")
    */
    class ExampleText extends AbstractResource
    {
        /**
        * @ORM\Column(type="string")
        */
        private $text;

        public function setText($text)
        {
            $this->text = $text;
        }

        public function getText()
        {
            return $this->text;
        }
    }


## Plugin configuration file

Your plugin must define its properties and the list of its resources in the *Resources/config/config.yml file*.
This file will be parsed by the plugin installator to install your plugin and create all your declared resources types in the database.

    plugin:
        # Set this to "true" if your plugin must have an entry in the plugins configuration page.
        has_options: true

        # Widgets declared by your plugin.
        widgets:
        # Each widget requires a name.
         - name: claroline_exemple
         - name: claroline_theanswertolifeuniverseandeverything

        # Properties of resources managed by your plugin
        # You can define as many resource types as you want in this file.
        resources:
            # "class" is the entity of your resource. This may be the entity of a existing
            # resource of the platform. This entity defines how the resource is stocked.
            # It may be usefull is your resource is a zip file with a particular structure.
            # In this case you can extend *Claroline\CoreBundle\Entity\Resource\File*.
          - class: Claroline\ExampleTextBundle\Entity\ExampleText
            # Your resource type name
            name: claroline_exampletext
            # Is it visible in the resource manager ?
            is_visible: true
            # Is it possible to navigate within your resource (does it have sub-resources ?)
            is_browsable: true
            # Icons for your resource.
            # They must be stored in the Resource/public/images/icons/large and small folders
            large_icon: res_text.png
            small_icon: res_text.png
            # Which are the actions we can fire from the resource manager.
            # Note that the resource manager will set some defaults actions
            #  (parameters, delete and download).
            actions:
                # The name of the action is the translation key that will be used to display
                #  the action in the list of available actions for your resource.
                #  The name will be passed to you by the Event manager.
              - name: open
                is_action_in_new_page: true

**/!\ it's a good practice to prefix your resources and widgets names to avoid possible conflicts with other plugins **

## Listener

The resource manager will trigger some events (Open, Delete...) on your resources. Your plugin must implements a listener to catch events that concern its resources and must apply appropriate action.

### Listener definition file

The definition of your listener must be placed in the *Resources/config/services/listeners.yml* file.

You declare in this file all events that you want to catch.

    services:
      claroline.listener.exampletext_listener:
        # Class that implements the listener
        class: Claroline\ExampleTextBundle\Listener\ExampleTextListener
        # The Symfony Container will be given to the class
        calls:
          - [setContainer, ["@service_container"]]
        tags:
          - { name: kernel.event_listener, event: create_form_claroline_exampletext, method: onCreateForm }
          - { name: kernel.event_listener, event: create_claroline_exampletext, method: onCreate }
          - { name: kernel.event_listener, event: delete_claroline_exampletext, method: onDelete }
          - { name: kernel.event_listener, event: export_claroline_exampletext, method: onExport }
          - { name: kernel.event_listener, event: copy_claroline_exampletext, method: onCopy }
          - { name: kernel.event_listener, event: open_claroline_exampletext, method: onOpen }
          - { name: kernel.event_listener, event: plugin_options_clarolineexampletext, method: onAdministrate }

Here is the list of events fired by the resource manager (lower case is forced here):

* create_form_*resourcetypename*
* create_*resourcetypename*
* delete_*resourcetypename*
* export_*resourcetypename*
* copy_*resourcetypename*
* *customaction*_*resourcetypename*

Where *resourcetypename* is the name of your resource in lowercase (e.g. "exampletext") and *customaction* is a custom action you defined earlier in the plugin configuration (e.g. "open").

This event is fired by the plugin managemement page:

* *plugin*_*options*_*myvendormyshortbundlename*

Where the shortbundle name is your bundle name without 'Bundle'.

#### note concerning the download

If your plugin don't catch the download event, a placeholder will be set in the archive.
The export event is fired for resource whose is_visible field is set to true.

### Listener implementation class

Define your listener class in the *Listener* folder.

    class ExampleTextListener extends ContainerAware
    {
      ...
      // Fired when a resource is removed.
      public function onDelete(DeleteResourceEvent $event)
      {
          $em = $this->container->get('doctrine.orm.entity_manager');
          foreach ($event->getResources() as $exampleText) {
              $em->remove($exampleText);
          }
          // Stop execution of further listeners
          $event->stopPropagation();
      }
      ...
    }

#### Forms

Please find the Symfony documentation here: http://symfony.com/doc/2.0/book/forms.html

##### Resources creation

Resources forms are a little be more complicated.

You can use the 'ClarolineCoreBundle:Resource:resource_form.html.twig' as  default form for your resource.


        ...
        //the form you defined with the symfony2 form component
        $form = $this->container
            ->get('form.factory')
            ->create(new ExampleTextType, new ExampleText());
        $content = $this->container->get('templating')->render(
            'ClarolineCoreBundle:Resource:resource_form.html.twig', array(
            'form' => $form->createView(),
            /*you must add the attribute resourceType to the twig File.
            The Resource Manager need
            to know wich kind of resource is going to be added.*/
            'resourceType' => 'claroline_exampletext'
            )
        );
        ...

**Warning**: don't forget the 'resourceType' attribute. Its value must be the 'name' field you defined in your config.yml file

If you want to write your own twig file, your form action must be:

    action="{{ path('claro_resource_create', {'resourceType':resourceType, 'parentInstanceId':'_instanceId'}) }}"

where resourceType is the 'name' field you defined in your config.yml file and _instanceId is a placeholder used
by the javascript manager.

###### Using existing forms & validations

This may be usefull if the *class* field you defined in your config file is an existing resource.
Let's assume you're using the Claroline\CoreBundle\Resource\File class.
Your listener should extends the Claroline FileListener.


    namespace MyVender\MyBundle\Listener;

    use Claroline\CoreBundle\Listener\Resource\FileListener;

    class MyListener extends FileListener {
     ...
    }

Then you must override the creationForm method. If you don't know wich method
to override, you can check wich method is called on the create_form_xxx event
in the config files.

    use Claroline\CoreBundle\Form\FileType;
    use Claroline\CoreBundle\Entity\Resource\File;
    use Claroline\CoreBundle\Library\Resource\Event\CreateFormResourceEvent;
    use Claroline\CoreBundle\Listener\Resource\FileListener;
    ...

    public function onCreateForm(CreateFormResourceEvent $event)
    {
        $form = $this->container->get('form.factory')->create(new FileType, new File());
        $content = $this->container->get('templating')->render(
            'ClarolineCoreBundle:Resource:resource_form.html.twig',
            array(
                'form' => $form->createView(),
                'resourceType' => 'myresourcetype'
            )
        );
        $event->setResponseContent($content);
        $event->stopPropagation();
    }

This function will create a File whose ResourceType is MyResource.
Because you extended the FileListener, you don't have to implement
the create_xxx event.

## Translations

Each plugin require several translations domains:

* plugin_description
* resource
* widget

We use lower case for every translation keys.

### plugin_description

Create the *plugin_description* file in your Resources/translations folder.

    plugin_description.en.yml

Here is the translation key used to translate your plugin name:

    myvendorbundleshortname : this is a translation

eg:

    clarolineexampletext: exemple

### resource

Create the *resource* file in your Resources/translations folder.

This is were you can translate the resource types you defined in your config file.
They'll be displayed at the resource creation.

/!\ everything must be lower case here

    exampletext: example

### widget

Create the *widget* file in your Resources/translations folder.
You can translate your widget names here.

    mywidgetname: mytranslation

Where mywidgetname is the name you defined in your config file.

## Resources

Each resource must be instanciated to be displayed by the resource manager.
You can consider every class extending AbstractResource as a way to stock
your resources datas.
This AbstractResource class has 2 very important relations.

### ResourceType

This entity job is to stock important attributes wich will differ depending on
the ResourceType.
Theses attributes are:

* isBrowsable;
* isVisible;

These attributes are defined in the resource section in your config file.

It also has relations to the customaction and the plugin tables.

### ResourceInstance

You can consider each ResourceInstance as a link to a resource. Many ResourceInstances
can link to the same resource (copy by reference).
Instances are created once the resource form is submitted.

These ResourceInstances contains the whole resource tree structure and are displayed by the resource manager interface.
In some cases you may want to define many resources with one acting as a container (like a folder) for the others in the
resource manager interface.


While the ResourceManager can instantiate your root resource, it's unaware of the others. You'll have to do that manually.

If your resource is "browsable" (defined in your config file), this step will be mandatory at some point.
Hopefully, this is very easy to do:

At first, get the claroline.resource.manager service.

     $creator = $this->get('claroline.resource.manager');

Then you must use the create() method.

Here is the method's signature:

     create(AbstractResource $resource, $parentInstanceId, $resourceType, $returnInstance = true, $mimeType = null, $user = null)

Where:

**mandatory :**

* $resource:
*the AbstractResource subclass you wrote*
* $parentInstanceId:
*the parent instance (container)*
* $resourceType:
*the name field defined in your config file

**optional :**

* $returnInstance:
*true|false: will return the new instance if set to true, if not it will return the resource itself.*
* $mimeType:
*if the resource is a file, the mimeType is usefull to display the correct icon*.
* $user:
*mainly used for testing purpose. This is the resource creator. If set to null, the default user will be the current one*.

Most listeners are working with resourceInsanceIds.
If you want to retrieve the resource linked to this instance, get the ResourceInstanceRepository:

    $instance = $em->getRepository('Claroline\CoreBundle\Entity\Resource\ResourceInstance')->find($resourceInsanceId);

Where $em is the EntityManager.
You can get the resource from there:

    $resource = $instance->getResource();


### Keeping the context

ResourceInstance has a mandatory relation to the AbstractWorkspace table.
The Workspace indicate the context in wich your instance was placed.

You can find the workspace using

    $workspace = $resourceInstance->getWorkspace();

Then your response must extends the workspace layout.

    {% extends "ClarolineCoreBundle:Workspace:layout.html.twig" %}

This layout requires the **workspace** parameter. Its value must be the $workspace
you got from the instance.

### Removing a Resource Plugin

Plugins can be managed with theses commands:

    claroline:plugin:install VendorName BundleName
    claroline:plugin:uninstall VendorName BundleName

If you're removing a plugin whose resource class is defined by the claroline platform,
Resources having the type managed by the plugin will stay under their 'super type'.
Otherwise, they'll be removed.

### Opening/Editing a resource

There is no predefined event for these actions.
If you want to implement them, you must create some custom actions (see plugin configuration file).

### File players

File is a basic resource type defined by the platform. Theses resources a different from
the others as their expected behavior is different depending on their mime type.

The Claroline platform consider each mime this way: baseMime/extension.

eg: video/mp4 where video is the base and mp4 is the extension.

Each time a user is trying to open a file, the platform will fire some events.
First it'll dispatch the most specific one:

    play_file_basetype_extension

If no response was given to the the event, it'll try the more generic one:

    play_file_basetype

Finally, it'll ask for the resource download.

#### Players implementation

In order to catch the event, your plugin must define a listener in your config (as explained above;
the only change is the event name).

This example will show you the main files of a basic HTML5 video player.

**The listener config file**

*Claroline\VideoPlayer\Resources\config\services\listener.yml*

    services:
        claroline.listener.video_player_listener:
            class: Claroline\VideoPlayerBundle\Listener\VideoPlayerListener
            calls:
                - [setContainer, ["@service_container"]]
            tags:
                - { name: kernel.event_listener, event: play_file_video, method: onOpenVideo }

**The listener class**

*Claroline\VideoPlayerBundle\Listener\VideoPlayerListener.php*

    namespace Claroline\VideoPlayerBundle\Listener;

    use Claroline\CoreBundle\Library\Resource\Event\PlayFileEvent;
    use Symfony\Component\DependencyInjection\ContainerAware;
    use Symfony\Component\HttpFoundation\Response;

    class VideoPlayerListener extends ContainerAware
    {
        public function onOpenVideo(PlayFileEvent $event)
        {
            $path = $this->container->getParameter('claroline.files.directory').DIRECTORY_SEPARATOR.$event->getInstance()->getResource()->getHashName();
            $content = $this->container->get('templating')
                ->render('ClarolineVideoPlayerBundle::video.html.twig',
                    array('workspace' => $event->getInstance()->getWorkspace(), 'path' => $path, 'video' => $event->getInstance()->getResource()));
            $response = new Response($content);
            $event->setResponse($response);
            $event->stopPropagation();
        }
    }

**The template twig file**

*Claroline\VideoPlayerBundle\Resources\view\video.html.twig*

    {% extends "ClarolineCoreBundle:Workspace:layout.html.twig" %}

    {% block section_content %}
    <video controls preload=none
        <source src="{{ path ('claro_stream_video', {'videoId': video.getId()})}}"/>
    </video>
    {% endblock %}

**The controller**

*Claroline\VideoPlayerBundle\Controller\VideoPlayerController.php*

    namespace Claroline\VideoPlayerBundle\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\Controller;
    use Symfony\Component\HttpFoundation\StreamedResponse;

    class VideoPlayerController extends Controller
    {
        public function streamAction($videoId)
        {
            $video = $this->get('doctrine.orm.entity_manager')->getRepository('ClarolineCoreBundle:Resource\File')->find($videoId);

            $response = new StreamedResponse();
            $path = $this->container->getParameter('claroline.files.directory').DIRECTORY_SEPARATOR.$video->getHashName();
            $response->setCallBack(function() use($path){
                readfile($path);
            });
            $response->headers->set('Content-Type', $video->getMimeType());

            return $response;
        }
    }

**The routing file**

*Claroline\VideoPlayerBundle\Resources\config\routing.yml*

    claro_stream_video:
    pattern: /stream/video/{videoId}
    defaults: { _controller: ClarolineVideoPlayerBundle:VideoPlayer:stream }

**What you should not forget**

* the config file
* the extension class
* the bundle class

## Widgets

Widgets can be displayed at 2 differents key pages:

* Dashboard home
* Workspace home

Every time a user is loading one of these page, the list of registered widgets will be loaded.
Every time the platform wants to display a widget, the event is fired

    widget_*widgetName*_*workspace|dashbloard*

Where

* widget is a prefix
* widgetName is the name of your widget defined in the config file.
* the last word is either workspace or dashboard depending on where the widget is displayed

### Catching the event

Define a listener in your listeners.yml file

    myvendor.listener.mybundle_widget:
      class: ...
      tags:
        - { name: kernel.event_listener, event: widget_widgetname_dashboard, method: onDisplay }

## Listener implementation

Simply set a string in the $event->setContent() method.

    use Claroline\CoreBundle\Library\Plugin\Event\DisplayWidgetEvent;
    ...
    function onDisplay(DisplayWidgetEvent $event)
    {
        $event->setContent('someContent');
    }


### Keeping the context

You can retrieve the workspace using
    $event->getWorkspace();

## Notification & tracking

No implementation yet.

## Extension class

Write the extension class in your DependencyInjection folder.

## Bundle class

Don't forget to add the bundle class.

## Controllers

On some events your listeners are supposed to send a response.
These responses can contain links wich will redirects to your controllers.

## The platform

### Services

You obviously have access to the platform services in your plugins.
You can find the list of services in the CoreBundle/Resources/services folder.

The most usefull services for plugin developpement should be:

* claroline.resource.manager
* claroline.workspace.creator

### Url redirections

### Javascripts

ClaroTools and Jquery are included by default.
You can add your scripts in the javascripts block.

    {% block javascripts %}
        {{ parent() }}
        <script src="{{ asset('bundles/mybundle/js/myjs.js') }}" type="text/javascript"></script>
    {% endblock %}

The ClaroUtils namespace contains some usefull methods for javascript development.
The ClaroUtils file is located in the CoreBundle/Resources/public/js/claro_utils.js

#### ajax request

sendRequest(...) is based on the jquery.ajax() function. It'll handle the platform errors and will display
the connexion form if no user is logged on when the request is sent.

#### others

### Dev tools

None so far.