# Getting started with Claroline plugin development

This tutorial aims to explain how to develop a plugin that manages a new resource type in the Claronext LMS.

## Prerequisites

### PHP

Claronext is developed in PHP and needs at least the 5.3 version.

### Symfony

Claronext is built on top of the Symfony framework (version 2). Plugins that you develop will be based on the same framework so you should have at least basic knowledge of it.

Please find the Symfony documentation here:
http://symfony.com/doc/current/index.html.

### Doctrine

Claronext makes a strong use of the Doctrine ORM. You have to use it too, at least for the parts that will be managed by the platform (mainly the resources).

We recommand anyway that you use the ORM for your whole plugin to be "database independant".

It is good practice to check SQL requests generated by the ORM and optimize the code to minimize the load on the database. The DQL (Doctrine Query language) is the right tool to "force" Doctrine  requesting the database the way **you** want.

Please find the Doctrine documentation here:
http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/index.html

## Directory structure

You must put the code of your plugin in the *src/plugin* folder.

You may choose to develop in the *Claroline* vendor folder or create your own one (e.g. *src/plugin/myVendorName*). There you create a new folder for each plugin.

As plugins are Symfony2 [bundles](http://symfony.com/doc/2.0/cookbook/bundles/best_practices.html), it is strongly recommanded that you follow bundles naming rules. So the folder of your plugin should be like this: *src/plugin/myVendorName/myPluginNameBundle*.

## Database tables

You must create a migration class building your tables in the existing database.

The class must extend [*BundleMigration*](http://symfony.com/doc/2.0/bundles/DoctrineMigrationsBundle/index.html) and be placed in the *Migrations* folder. Its name must start with *Version* and end with a timestamp (YYYMMDDHHMMSS); e.g. *Version20121002000000.php*.

This class will be executed by the plateform when installing your plugin. It must contains two methods: up() and down(). They will be called to create or remove your tables to/from the database.

    /**
    *  BundleMigration is written on top of Doctrine\DBAL\Migrations\AbstractMigration
    *  and contains some helper methods.
    *  You can use the doctrine migration class as well (see the doctrine doc).
    */
    class Version20121002000000 extends BundleMigration
    {

        /**
        * Will be fired at the plugin installation.
        * @param \Doctrine\DBAL\Schema\Schema $schema
        */
        public function up(Schema $schema)
        {
            $this->createExampleTextTable($schema);
        }

        /**
        * Will be fired at the plugin uninstallation.
         * @param \Doctrine\DBAL\Schema\Schema $schema
         */
        public function down(Schema $schema)
        {
            $schema->dropTable('claro_example_text');
        }

        /**
        * Create the 'claro_example_text' table.
        * @param \Doctrine\DBAL\Schema\Schema $schema
        */
        public function createExampleTextTable(Schema $schema)
        {
            // Table creation
            $table = $schema->createTable('claro_example_text');
            // Add an auto increment id
            $this->addId($table);
            // Add a column
            $table->addColumn('text', 'text');
        }
    }

## Doctrine entities

Define your Doctrine entities in the Entity folder.

If your identity is a resource that must be recognized by the platform and manageable in the resource manager then you must extend the *Claroline\CoreBundle\Entity\Resource\AbstractResource* class.

    /**
    * @ORM\Entity
    * @ORM\Table(name="claro_example_text")
    */
    class ExampleText extends AbstractResource
    {
        /**
        * @ORM\Column(type="string")
        */
        private $text;

        public function setText($text)
        {
            $this->text = $text;
        }

        public function getText()
        {
            return $this->text;
        }
    }


## Plugin configuration file

Your plugin must define its properties and the list of its resources in the *Resources/config/config.yml file*.
This file will be parsed by the plugin installator to install your plugin and create all your declared resources types in the database.

    plugin:
        # Set this to "true" if your plugin must have an entry in the plugins configuration page.
        has_options: true
        # Translation key that will be used to display the name of your plugin
        plugin_translation_name_key: example
        # Translation domain of your plugin. Will allow to load your transation file
        # (domain.language.yml, e.g. example.fr.yml)
        plugin_translation_domain: example

        # Properties of resources managed by your plugin
        # You can define as many resource types as you want in this file.
        resources:
            # "class" is the entity of your resource. This may be the entity of a existing
            # resource of the platform if you want to extend it,
            # e.g. Claroline\CoreBundle\Entity\Resource\File.
          - class: Claroline\ExampleTextBundle\Entity\ExampleText
            # Your resource type name
            name: ExampleText
            # Is it visible in the resource manager ?
            is_visible: true
            # Is it possible to navigate within your resource (does it have sub-resources ?)
            is_browsable: true
            # Is it possible to download it ?
            is_downloadable: true
            # Icons for your resource.
            # They must be stored in the Resource/public/images/icons/large and small folders
            large_icon: res_text.png
            small_icon: res_text.png
            # Which are the actions we can fire from the resource manager.
            # Note that the resource manager will set some defaults actions
            #  (parameters, delete and download if you set the "downloadable" parameter to true).
            actions:
                # The name of the action is the translation key that will be used to display
                #  the action in the list of available actions for your resource.
                #  The name will be passed to you by the Event manager.
              - name: open
                is_action_in_new_page: true

## Listener

The resource manager will trigger some events (Open, Delete...) on your resources. Your plugin must implements a listener to catch events that concern its resources and must apply appropriate action.

### Listener definition file

The definition of your listener must be placed in the *Resources/config/services/listeners.yml* file.

You declare in this file all events that you want to catch.

    services:
      claroline.listener.exampletext_listener:
        # Class that implements the listener
        class: Claroline\ExampleTextBundle\Listener\ExampleTextListener
        # The Symfony Container will be given to the class
        calls:
          - [setContainer, ["@service_container"]]
        tags:
          - { name: kernel.event_listener, event: create_form_exampletext, method: onCreateForm }
          - { name: kernel.event_listener, event: create_exampletext, method: onCreate }
          - { name: kernel.event_listener, event: delete_exampletext, method: onDelete }
          - { name: kernel.event_listener, event: export_exampletext, method: onExport }
          - { name: kernel.event_listener, event: copy_exampletext, method: onCopy }
          - { name: kernel.event_listener, event: open_exampletext, method: onOpen }

Here is the list of events fired by the resource manager:

* create_form_*resourcetypename*
* create_*resourcetypename*
* delete_*resourcetypename*
* export_*resourcetypename*
* copy_*resourcetypename*
* *customaction*_*resourcetypename*

Where *resourcetypename* is the name of your resource in lowercase (e.g. "exampletext") and *customaction* is a custom action you defined earlier in the plugin configuration (e.g. "open").

### Listener implementation class

Define your listener class in the *Listener* folder.

    class ExampleTextListener extends ContainerAware
    {
      ...
      // Fired when a resource is removed.
      public function onDelete(DeleteResourceEvent $event)
      {
          $em = $this->container->get('doctrine.orm.entity_manager');
          foreach ($event->getResources() as $exampleText) {
              $em->remove($exampleText);
          }
          // Stop execution of further listeners
          $event->stopPropagation();
      }
      ...
    }

++ ????? Explications m√©thodes (avec explication de base pour Forms dans createForm)

## Extension class

Write the extension class in your DependencyInjection folder.

## Bundle class

Don't forget to add the bundle class.

### ?? Controlers



